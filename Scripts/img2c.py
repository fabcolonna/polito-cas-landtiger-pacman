#!/usr/bin/env python3

from PIL import Image
from argparse import ArgumentParser as ArgParser

#? Compresses pixel data using RLE algorithm, to reduce output size.
def rle_compress(data, w):
    if not data:
        return []
    
    compressed = []
    for row_start in range(0, len(data), w): # Iterate over each row
        row = data[row_start:row_start + w]  # Get the entire row data
        
        count = 1
        prev_value = row[0]
        for value in row[1:]:
            if value == prev_value:
                count += 1
            else:
                compressed.append((count, prev_value))
                count = 1
            prev_value = value
        compressed.append((count, prev_value)) # Append last line of the row
    return compressed

#? Dumps the list to a C array definition.
def dump_to(file, w, h, pixels, name, meaningful_alpha):
    with open(file, "w") as out:
        incl_guard = f"__{name.upper()}_H"

        out.write(
f"""// This image array was auto-generated by img2c.py. Do not edit it manually.
#ifndef {incl_guard}
#define {incl_guard}

#include "utils.h"
#include "glcd_types.h"

// clang-format off

const u32 Image_{name}Data[] = {{\n""")
        
        for count, value in pixels:
            if meaningful_alpha:
                out.write(f"\t{count}, 0x{value:08X},\n")
            else:
                value &= 0x00FFFFFF
                out.write(f"\t{count}, 0x{value:06X},\n")
        
        out.write(
f"""}};

// clang-format on

const LCD_Image Image_{name} = {{
    .pixels = Image_{name}Data,
    .width = {w},
    .height = {h},
    .has_alpha = {"true" if meaningful_alpha else "false"}
}};

#endif""")
        
#? Merges separate R, G, B, A channels in one value
#? Format: 0xAARRGGBB
def to_argb(r, g, b, a):
    return a << 24 | r << 16 | g << 8 | b

#? Checks if the image has meaningful alpha data
def is_alpha_meaningful(img):
    alpha = img.getchannel("A")
    return alpha.getextrema() != (255, 255)

#? Main program.
def main():
    parser = ArgParser(prog='img2c', description='Converts an image into a C-style RLE-compressed array of (A)RGB values')
    parser.add_argument('img_file', type=str, help='Image file to convert')
    parser.add_argument('out_file', type=str, help='Output file in which to write the C-style array')

    image_opts = parser.add_mutually_exclusive_group()
    image_opts.add_argument('-s', type=float, help='Scale factor to apply to the image')
    image_opts.add_argument('-r', type=int, nargs=2, help='Resize the image to the given dimensions')

    output_opts = parser.add_argument_group()
    output_opts.add_argument('-S', type=str, help='Save the image with the given scale or dimensions')
    output_opts.add_argument('-n', type=str, help='Name of the image object in the output file', required=True)
    args = parser.parse_args()

    with Image.open(args.img_file) as img:
        img = img.convert("RGBA")
        has_meaningful_alpha = is_alpha_meaningful(img)
        
        if not has_meaningful_alpha:
            print("Image does not have meaningful alpha data (or it doesn't have it at all). Saving as RGB.")
        else:
            print("Image has meaningful alpha. Saving as ARGB.")
 
        # Scale or resize if requested
        if args.s:
            img_w, img_h = img.size
            img = img.resize((int(img_w * args.s), int(img_h * args.s)))
        elif args.r:
            img = img.resize(tuple(args.r))
        
        # Optionally save the processed image
        if args.S:
            img.save(args.S)

        # Compress data using RLE to reduce array size
        width, height = img.size
        argb_data = [to_argb(r, g, b, a) for r, g, b, a in img.getdata()]
        rle_data = rle_compress(argb_data, width)
        dump_to(args.out_file, width, height, rle_data, args.n, has_meaningful_alpha)

if __name__ == "__main__":
    main()
