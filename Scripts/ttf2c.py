#!/usr/bin/env python3

from os import makedirs
from shutil import rmtree
from PIL import Image, ImageFont, ImageDraw
from argparse import ArgumentParser as ArgParser

def dump_to_c(font: ImageFont.FreeTypeFont, out_file: str, font_size: int, font_out_name: str, bmp_directory: str = None):
    charset = ''.join([chr(i) for i in range(32, 127)])


    with open(out_file, "w") as out:
        incl_guard = f"__FONT_{font_out_name.upper()}_{font_size}_H"
        type_name = f"Font_{font_out_name}{font_size}"
        data_name = f"{type_name}Data"
        char_widths_name = f"{type_name}CharWidths"
        char_heights_name = f"{type_name}CharHeights"
        baseline_offsets_name = f"{type_name}BaselineOffsets"

        char_heights = []
        char_widths = []
        baseline_offsets = []

        # Ascent (the distance from the baseline to the top of the tallest char, e.g. 'H')
        # Descent (the distance from the baseline to the bottom of the lowest char, e.g 'p'). It's a negative value
        ascent, descent = font.getmetrics()

        out.write(
f"""// This font array was auto-generated by ttf2c.py. Do not edit it manually.
#ifndef {incl_guard}
#define {incl_guard}

#include "utils.h"
#include "glcd_types.h"

// Font size: {font_size} px

// clang-format off

const u32 {data_name}[] = {{\n""")
        for char in charset:
            char_img = Image.new("1", (font.size, font.size))
            char_draw = ImageDraw.Draw(char_img)
            char_draw.text((0, 0), char, font=font, fill="white")

            bbox = char_draw.textbbox((0, 0), char, font=font)

            # (x_min, y_min) - top left corner, (x_max, y_max) - bottom right corner
            # y_min tells us how much the char is above the baseline
            # For chars with ascenders (e.g. 'H'), we need y_min to calculate how much
            # we should move the char bitmap vertically, to align it with the baseline.
            x_min, y_min, x_max, y_max = bbox
            w = x_max - x_min
            h = y_max - y_min
            char_widths.append(w)
            char_heights.append(h)
            baseline_offsets.append(ascent - y_min)

            # We need to keep info about the offset of each char from the baseline,
            # otherwise we won't be able to dray taller/shorter chars correctly, e.g. 'H' and 'p'.
            
    
            # Drawing red rectangle & saving the img to check the bbox accuracy
            #char_draw.rectangle(bbox, outline="red")
            char_img.save(f"{bmp_directory}/{ord(char)}.bmp") if bmp_directory else None
            # print(f"Char: {char}, width: {w}px, height: {h}px")

            out.write(f"/* {char}: w={w}, h={h} */\t")
            for y in range(y_min, y_max):
                row = 0
                for x in range(x_min, x_max):
                    value = 1 if char_img.getpixel((x, y)) > 0 else 0
                    row = (row << 1) | value
                out.write(f"0x{row:X}, ")
            out.write("\n")
        out.write(
f"""}};

const u16 {char_widths_name}[] = {{
    {', '.join(map(str, char_widths))}
}}; 

const u16 {char_heights_name}[] = {{
    {', '.join(map(str, char_heights))}
}};

const u16 {baseline_offsets_name}[] = {{
    {', '.join(map(str, baseline_offsets))}
}};
        
// clang-format on

const LCD_Font {type_name} = {{
    .data = {data_name},
    .data_size = {len(charset)},
    .char_widths = {char_widths_name},
    .max_char_width = {max(char_widths)},
    .char_heights = {char_heights_name},
    .max_char_height = {max(char_heights)},
    .baseline_offsets = {baseline_offsets_name},
}};

#endif""")

#? Main Program
parser = ArgParser(prog='ttf2c', description='Converts a TTF BMP font into a C-style array, containing chars in ASCII order')
parser.add_argument('ttf_file', type=str, help='TTF font file to convert')
parser.add_argument('out_file', type=str, help='Output file in which to write the C-style array')
parser.add_argument('-s', '--size', type=int, help='Font size, up to 32', required=True)
parser.add_argument('-n', '--name', type=str, help='Name of the structures in the output file', required=True)
parser.add_argument('--bmps-dir', type=str, help='Directory to save BMP files with bounding boxes (for debugging purposes)')

args = parser.parse_args()
if args.size > 32 or args.size < 1:
    raise ValueError("Font size must be in range (1, 32), inclusive")

try:
    font = ImageFont.truetype(args.ttf_file, size=args.size)
    if args.bmps_dir:
        rmtree(args.bmps_dir, ignore_errors=True)
        makedirs(args.bmps_dir)

    dump_to_c(font, args.out_file, args.size, args.name, args.bmps_dir)
except Exception as e:
    print(e)